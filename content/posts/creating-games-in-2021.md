---
title: Creating Games in 2021
date: 2021-09-29T08:08:58
tags:
  - engineering
  - games
images:
  - https://images.unsplash.com/photo-1537963447914-dbc04b81de27?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMTc3M3wwfDF8c2VhcmNofDl8fGdhbWV8ZW58MHx8fHwxNjMyODY3ODcz&ixlib=rb-1.2.1&q=80&w=2000
---

I enjoy working on games on my free time. Sometimes during doing something completely unrelated to games some interesting game concepts comes into my mind and I want to make them. So my story starts there...

So, recently, after a long break from game development I wanted to try developing some games just for fun and decorate my project graveyard. The first thing came in my mind was using a game engine and bootstrapping a project in one of them. Because I've had past experience on Unity and C# I wanted to try it firstly. I've get into unity website and started downloading, during waiting for the download to finish I remembered my past experience with it. If you want to do advanced things it helps you a lot. But if any case you want to work with bare minimum like drawing a box on the screen or a line things become a bit complicated and unnatural since unity is designed to eliminate working with low level geometries. But this also means to make a simple box on the screen you'll have to deal with it's transformation, sprite, material, lighting, camera, transformation, and even more stuff if you want to move it left and right. It's actually great since you'll not have to deal with viewport, size, scale, how it displays and many more slightly complicated stuff. But for bare minimum games - especially when you just want to try something in your mind out in short amount of time, those things can easily bore you. Also I noticed that installation takes a bit longer because Unity isn't just a tool for making small 2d games. It's consist tools required for building both 2d and 3d games and some shared components like audio and animation stuff alongside with core / platform level components. So that's why it weights a lot. But as I wait I get bored and gave up because in past when I've tried making games with unity, all the fine touches that needed to make something work out was bored me easily so I thought that it'll probably happen again if I give it another try.

So I started looking for alternatives. Unreal Engine was very popular and hyped alternative to Unity but it's not for me because first. it's optimized for 3d gfx, doing 2d is not recommended. and secondly it's very overpowered and with great power comes great responsibility, in Unreal Engine's case it means I'll need to deal with even more customizations and fine touches. Also I didn't have enough time to learn another game engine. So Unreal Engine wasn't an option for me. At least as of today.. Maybe I'll give it a try in future for a bigger projects hopefully.

Since neither Unity nor Unreal Engine was an option for me, I wanted to try other exists game engines. Because of my recent search history Google also realized that and modified my YouTube recommendations to show me some videos about another game engines that gains popularity - Godot. It's a free, lightweight and open source game engine. It's simple interface and lightweight download size impressed me on first sight. So I looked into it to check whether it would work out for me or not.

Unfortunately Godot wasn't like anything I had used before. I was struggled to work with editor, or to manage resources, and additionally to that it uses Gdscript language for scripting which have 2 flaws for me. It was python flavored - which means uses intention rather than braces for blocks, scoping and secondly it's dynamically typed language. While the first concern is opinion based and could be used to it after gaining some experience, my second concern that it's dynamically typed language couldn't be ignored easily. Especially after working with static typed languages for overy years it becomes really hard to get used to dynamic typed ones. You'll miss some features that you get out of the box when you switch, like: intellisense and compile time type checks. Additionally to that the Node system on Godot weren't similar to hierarchy system from Unity which confused me a bit. And last but not least it was a bit harder to find resources related to Godot. It's another crucial point actually because Godot itself is pretty powerful and feature rich engine which means it requires enough time and resources for learning and a good documentation + community made materials are huge part of it, but compared to its competitors with similar feature set, resources for godot isn't probably as much. At least during the small time window that I wanted to give it a try I had hard time figuring out how could I use a png with multiple sprites to draw individual sprite on screen. Anyways even if Godot is a great and lightweight game engine, the scripting language and the overall workflow familiarity forced me to keep looking for alternatives.

I've also checked some alternatives like cocos2d-x, libGDX and LÖVE. But each one had its own flaws **for me**. Cocos2d-x was not easy like others to setup and start coding the game. I've previously used libGDX for making some small mobile games, so I'm a bit familiar with it but I wanted to try something else this time.

Then I came across LÖVE game engine. It was very easy to install and start coding your games. You just download a small executable file, maybe setup your PATH if you want and you're ready to go. I really loved it's workflow and api design. But the main pitfall for me was it's scripting language - Lua. I haven't used Lua before but I did know something about that was - it's another dynamically typed language. So same flaws I've written for gdscript also applies to writing code with lua. I don't know why but currently I can't bear with dynamically typed languages. I don't like to memorize apis even the ones I've written myself. I just used to see a popup of suggestions when I press dot key after writing `player`. You can get some sort of similar experience with dynamically typed languages too but it's not powerful as intellisense tools provided for static typed languages. Also compile time type checks adds another layer for catching bugs before even they happens.

But the simplicity and lightweightness of Love really impressed me, I really wanted to use it but also I really didn't wanted to use Lua with it. So I have asked myself why not reinvent the wheel once again? I wanted to write an engine with same lightweightness and simplicity of love but using static typed language for scripting. Yes I know that reinventing wheel is meaningless and waste of time. But we're not inventing the same wheel every time, we'll be inventing our own wheel with different set of features and we'll be going to learn lots of new experiences during the journey. So I thought it'll worth it.

## So what's next?

In short I'm planning to create a game engine. It'll probably going to support only 2d graphics because there's lots of amazing 3d engines and I wanted to keep scope of this project narrow enough so I could at least finish it at some point. And additionally to that I'm planning to write custom scripting language for the engine. Recently I was learning about writing parsers, compilers, virtual machines and more interesting stuff from [a book by Bob Nystrom](http://craftinginterpreters.com/). I thought it would be more interesting if I could create an embeddable & statically typed programming language alongside with engine so I could use stuff I learnt before. I know it'll probably going to increase scope of the project and will probably make the engine perform worst than for example if I've used Lua or something else that's optimized over the course of years. But I'm not planning to someone else making games with it, I'm just doing it as a side project, and for fun & sake of learning new stuff.

So I have separated the entire process to some major parts and I'll probably follow in that order:

1. **Language design** - syntax, features, keywords and other decisions to be made
2. **Creating interpreter** - writing a compiler and bytecode VM for running the language code
3. **Engine design** - making some decisions regarding engine architecture
4. **Graphics foundation** - writing a simple foundation for graphics engine
5. **FFI / engine api** - designing and writing engine api for calling functions from scripting language
6. **Basic input system** - researching and writing keyboard and pointer input system for the engine. In future revisions I'm planning to add support for joystick input too.
7. **Sound system** - researching and writing sound system for the engine

That's all the basics for now and things probably will going to be changed multiple times over time when needed. I just wanted to share what I'm planning to do and will write posts about the future updates if I somehow keep working on the project long enough.

Thanks for reading till this far!